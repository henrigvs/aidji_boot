/*
 * Copyright 2025 Henri GEVENOIS
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package be.aidji.boot.security.jwt.stand_alone;

import be.aidji.boot.core.exception.SecurityException;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.time.Instant;
import java.util.Base64;
import java.util.Date;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

@DisplayName("JwtTokenProviderStandAlone")
class JwtTokenProviderStandAloneTest {

    private JwtTokenProviderStandAlone provider;
    private KeyPair keyPair;

    @BeforeEach
    void setUp() throws Exception {
        // Generate RSA key pair for testing
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
        keyGen.initialize(2048);
        keyPair = keyGen.generateKeyPair();
    }

    @Nested
    @DisplayName("Constructor with auto-generated keys")
    class AutoGeneratedKeysTests {

        @Test
        @DisplayName("should create provider with auto-generated keys")
        void shouldCreateProviderWithAutoGeneratedKeys() {
            // When
            JwtTokenProviderStandAlone provider = new JwtTokenProviderStandAlone(
                    "test-issuer",
                    2048,
                    3600L
            );

            // Then
            assertThat(provider).isNotNull();
            assertThat(provider.getIssuer()).isEqualTo("test-issuer");
            assertThat(provider.getPrivateKey()).isNotNull();
            assertThat(provider.getPublicKey()).isNotNull();
            assertThat(provider.getKeyId()).isNotNull();
        }

        @Test
        @DisplayName("should generate and validate tokens with auto-generated keys")
        void shouldGenerateAndValidateTokensWithAutoGeneratedKeys() {
            // Given
            JwtTokenProviderStandAlone provider = new JwtTokenProviderStandAlone(
                    "test-issuer",
                    2048,
                    3600L
            );
            Map<String, Object> claims = Map.of("role", "USER", "email", "test@example.com");

            // When
            String token = provider.generateToken("testuser", claims);
            Claims extractedClaims = provider.validateToken(token);

            // Then
            assertThat(token).isNotBlank();
            assertThat(extractedClaims.getSubject()).isEqualTo("testuser");
            assertThat(extractedClaims.get("role")).isEqualTo("USER");
            assertThat(extractedClaims.get("email")).isEqualTo("test@example.com");
            assertThat(extractedClaims.getIssuer()).isEqualTo("test-issuer");
        }
    }

    @Nested
    @DisplayName("Constructor with provided keys")
    class ProvidedKeysTests {

        @Test
        @DisplayName("should create provider with PEM keys")
        void shouldCreateProviderWithPemKeys() throws Exception {
            // Given
            String privateKeyPem = toPem((RSAPrivateKey) keyPair.getPrivate());
            String publicKeyPem = toPem((RSAPublicKey) keyPair.getPublic());

            // When
            JwtTokenProviderStandAlone provider = new JwtTokenProviderStandAlone(
                    "test-issuer",
                    privateKeyPem,
                    publicKeyPem,
                    3600L
            );

            // Then
            assertThat(provider).isNotNull();
            assertThat(provider.getIssuer()).isEqualTo("test-issuer");
            assertThat(provider.getPrivateKey()).isNotNull();
            assertThat(provider.getPublicKey()).isNotNull();
        }

        @Test
        @DisplayName("should create provider with Base64-encoded PEM keys")
        void shouldCreateProviderWithBase64EncodedPemKeys() throws Exception {
            // Given
            String privateKeyPem = toPem((RSAPrivateKey) keyPair.getPrivate());
            String publicKeyPem = toPem((RSAPublicKey) keyPair.getPublic());
            String privateKeyBase64 = Base64.getEncoder().encodeToString(privateKeyPem.getBytes());
            String publicKeyBase64 = Base64.getEncoder().encodeToString(publicKeyPem.getBytes());

            // When
            JwtTokenProviderStandAlone provider = new JwtTokenProviderStandAlone(
                    "test-issuer",
                    privateKeyBase64,
                    publicKeyBase64,
                    3600L
            );

            // Then
            assertThat(provider).isNotNull();
            assertThat(provider.getPrivateKey()).isNotNull();
            assertThat(provider.getPublicKey()).isNotNull();
        }
    }

    @Nested
    @DisplayName("generateToken")
    class GenerateTokenTests {

        @BeforeEach
        void setUp() throws Exception {
            String privateKeyPem = toPem((RSAPrivateKey) keyPair.getPrivate());
            String publicKeyPem = toPem((RSAPublicKey) keyPair.getPublic());
            provider = new JwtTokenProviderStandAlone("test-issuer", privateKeyPem, publicKeyPem, 3600L);
        }

        @Test
        @DisplayName("should generate valid JWT token")
        void shouldGenerateValidJwtToken() {
            // Given
            Map<String, Object> claims = Map.of("role", "ADMIN", "department", "IT");

            // When
            String token = provider.generateToken("admin", claims);

            // Then
            assertThat(token).isNotBlank();
            assertThat(token.split("\\.")).hasSize(3); // JWT has 3 parts
        }

        @Test
        @DisplayName("should include all claims in token")
        void shouldIncludeAllClaimsInToken() {
            // Given
            Map<String, Object> claims = Map.of(
                    "role", "USER",
                    "email", "user@example.com",
                    "department", "Engineering"
            );

            // When
            String token = provider.generateToken("testuser", claims);
            Claims extractedClaims = provider.validateToken(token);

            // Then
            assertThat(extractedClaims.get("role")).isEqualTo("USER");
            assertThat(extractedClaims.get("email")).isEqualTo("user@example.com");
            assertThat(extractedClaims.get("department")).isEqualTo("Engineering");
        }

        @Test
        @DisplayName("should set correct issuer and subject")
        void shouldSetCorrectIssuerAndSubject() {
            // Given
            Map<String, Object> claims = Map.of();

            // When
            String token = provider.generateToken("testuser", claims);
            Claims extractedClaims = provider.validateToken(token);

            // Then
            assertThat(extractedClaims.getSubject()).isEqualTo("testuser");
            assertThat(extractedClaims.getIssuer()).isEqualTo("test-issuer");
        }

        @Test
        @DisplayName("should set expiration time based on TTL")
        void shouldSetExpirationTimeBasedOnTtl() {
            // Given
            Map<String, Object> claims = Map.of();
            long beforeGeneration = Instant.now().getEpochSecond();

            // When
            String token = provider.generateToken("testuser", claims);
            Claims extractedClaims = provider.validateToken(token);
            long afterGeneration = Instant.now().getEpochSecond();

            // Then
            long expirationTime = extractedClaims.getExpiration().toInstant().getEpochSecond();
            long expectedExpiration = beforeGeneration + 3600;
            assertThat(expirationTime).isBetween(expectedExpiration - 2, afterGeneration + 3600 + 2);
        }

        @Test
        @DisplayName("should include key ID in token header")
        void shouldIncludeKeyIdInTokenHeader() {
            // Given
            Map<String, Object> claims = Map.of();

            // When
            String token = provider.generateToken("testuser", claims);

            // Then - Extract and verify header
            String header = token.split("\\.")[0];
            String headerJson = new String(Base64.getUrlDecoder().decode(header));
            assertThat(headerJson).contains("\"kid\"");
            assertThat(headerJson).contains(provider.getKeyId());
        }
    }

    @Nested
    @DisplayName("validateToken")
    class ValidateTokenTests {

        @BeforeEach
        void setUp() throws Exception {
            String privateKeyPem = toPem((RSAPrivateKey) keyPair.getPrivate());
            String publicKeyPem = toPem((RSAPublicKey) keyPair.getPublic());
            provider = new JwtTokenProviderStandAlone("test-issuer", privateKeyPem, publicKeyPem, 3600L);
        }

        @Test
        @DisplayName("should validate valid token")
        void shouldValidateValidToken() {
            // Given
            String token = provider.generateToken("testuser", Map.of("role", "USER"));

            // When
            Claims claims = provider.validateToken(token);

            // Then
            assertThat(claims).isNotNull();
            assertThat(claims.getSubject()).isEqualTo("testuser");
            assertThat(claims.get("role")).isEqualTo("USER");
        }

        @Test
        @DisplayName("should throw SecurityException for expired token")
        void shouldThrowExceptionForExpiredToken() throws Exception {
            // Given - Create an expired token
            String token = Jwts.builder()
                    .subject("testuser")
                    .issuer("test-issuer")
                    .issuedAt(Date.from(Instant.now().minusSeconds(7200)))
                    .expiration(Date.from(Instant.now().minusSeconds(3600)))
                    .signWith(provider.getPrivateKey(), Jwts.SIG.RS256)
                    .compact();

            // When / Then
            assertThatThrownBy(() -> provider.validateToken(token))
                    .isInstanceOf(SecurityException.class)
                    .hasMessageContaining("Token expired");
        }

        @Test
        @DisplayName("should throw SecurityException for token with invalid signature")
        void shouldThrowExceptionForInvalidSignature() throws Exception {
            // Given - Create token with different key
            KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
            keyGen.initialize(2048);
            KeyPair differentKeyPair = keyGen.generateKeyPair();

            String token = Jwts.builder()
                    .subject("testuser")
                    .issuer("test-issuer")
                    .issuedAt(Date.from(Instant.now()))
                    .expiration(Date.from(Instant.now().plusSeconds(3600)))
                    .signWith(differentKeyPair.getPrivate(), Jwts.SIG.RS256)
                    .compact();

            // When / Then
            assertThatThrownBy(() -> provider.validateToken(token))
                    .isInstanceOf(SecurityException.class)
                    .hasMessageContaining("Invalid token");
        }

        @Test
        @DisplayName("should throw SecurityException for malformed token")
        void shouldThrowExceptionForMalformedToken() {
            // Given
            String malformedToken = "not.a.valid.jwt";

            // When / Then
            assertThatThrownBy(() -> provider.validateToken(malformedToken))
                    .isInstanceOf(SecurityException.class)
                    .hasMessageContaining("Invalid token");
        }
    }

    @Nested
    @DisplayName("isValid")
    class IsValidTests {

        @BeforeEach
        void setUp() throws Exception {
            String privateKeyPem = toPem((RSAPrivateKey) keyPair.getPrivate());
            String publicKeyPem = toPem((RSAPublicKey) keyPair.getPublic());
            provider = new JwtTokenProviderStandAlone("test-issuer", privateKeyPem, publicKeyPem, 3600L);
        }

        @Test
        @DisplayName("should return true for valid token")
        void shouldReturnTrueForValidToken() {
            // Given
            String token = provider.generateToken("testuser", Map.of());

            // When
            boolean valid = provider.isValid(token);

            // Then
            assertThat(valid).isTrue();
        }

        @Test
        @DisplayName("should return false for expired token")
        void shouldReturnFalseForExpiredToken() throws Exception {
            // Given
            String token = Jwts.builder()
                    .subject("testuser")
                    .issuedAt(Date.from(Instant.now().minusSeconds(7200)))
                    .expiration(Date.from(Instant.now().minusSeconds(3600)))
                    .signWith(provider.getPrivateKey(), Jwts.SIG.RS256)
                    .compact();

            // When
            boolean valid = provider.isValid(token);

            // Then
            assertThat(valid).isFalse();
        }

        @Test
        @DisplayName("should return false for malformed token")
        void shouldReturnFalseForMalformedToken() {
            // Given
            String token = "invalid.token";

            // When
            boolean valid = provider.isValid(token);

            // Then
            assertThat(valid).isFalse();
        }
    }

    // ========== Helper Methods ==========

    private String toPem(RSAPrivateKey privateKey) {
        String encoded = Base64.getEncoder().encodeToString(privateKey.getEncoded());
        return "-----BEGIN PRIVATE KEY-----\n" + encoded + "\n-----END PRIVATE KEY-----";
    }

    private String toPem(RSAPublicKey publicKey) {
        String encoded = Base64.getEncoder().encodeToString(publicKey.getEncoded());
        return "-----BEGIN PUBLIC KEY-----\n" + encoded + "\n-----END PUBLIC KEY-----";
    }
}
